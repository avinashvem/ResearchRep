\section{Introduction and Problem Statement}
\label{sec:introduction}
We consider the pattern matching problem in the random setting which is a problem that has been studied extensively in computer science \cite{}. In this problem, we have a signal $\xv \coleq (x[1], x[2],\ldots, x[N])$ of length $N$ symbols representing a string, library or database. We first consider the random setting of the problem in which $x[i]$'s are a sequence of independent and identically distributed (i.i.d) random variables taking values in $\mathcal{A} \coleq \{1,-1\}$, although extensions to other alphabets $\mathcal{A} \subseteq \mathbb{R}$ are possible. We assume that a sketch of $\xv$ can be computed offline and stored, and the one-time computational complexity of creating the sketch is ignored.

{\bf Exact Pattern Matching:} In the exact pattern matching problem, a substring of length $M$ of $\xv$, namely $\yv \coleq \xv[\tau:\tau+M-1]$ is obtained by taking $M$ consecutive symbols from $\xv$ and is presented as a query. This pattern may appear within $\xv$ in $L$ different locations $\tau_1,\tau_2,\ldots,\tau_L$ and the objective is to determine all the locations $\tau_i, \forall i\in[1:L]$. We consider the probabilistic version where our objective is to recover the matching locations with a probability that approaches 1 as $M,N \rightarrow \infty$.

{\bf Approximate Pattern Matching:} In the approximate pattern matching version, $\yv$ is a noisy version of a substring, i.e., $\yv = \xv[\tau:\tau+L-1] \odot \bv$ where $\bv$ is a noise sequence with $b[i] \in \pm 1$ such that $d_H(\yv,\xv[\tau:\tau+M-1]) \leq K$. Here $d_H$ denotes the Hamming distance, and $\odot$ represents component-wise multiplication. The objective is to determine all locations $\tau_i$ such that $d_H(\yv,\xv[\tau_i:\tau_i+M-1]) \leq K$ with a probability that approaches 1 as $K, M$ and $N \rightarrow \infty$.

These problems are relevant to many applications including text matching, DNA sequencing, and is particularly relevant now due to the interest in applications involving huge volumes of data. The presented results are most useful in the following situations - (i) the string $\xv$ is available before querying and one time computations such as computing a sketch of $\xv$ can be performed off line and stored, and the complexity of computing the sketch of $\xv$ can be ignored. Then, when queries in the form of $\yv$ appear, one would like to decrease the computational complexity in searching for the string $\yv$. (ii) The string $\xv$ is not centrally available but parts of the string are sensed by different data collecting nodes distributively and communicated to a central server. A search query is presented to the server and the server needs to decide if the string appeared in the data sensed by one or more of the distributed nodes and the time instants where the query appeared. In this case, we would like to minimize the amount of data communicated by the nodes to the server and the computational complexity in searching for the string. Finally, the proposed approach is most useful when the query $\yv$ is not a pattern that can be predicted and, therefore, creating a look up table to quickly identify patterns is not efficient. For e.g., $\xv$ is an i.i.d sequence of $\pm 1$ and $\yv$ could be a substring of $\xv$.

A naive approach to searching for a substring $\yv$ in $\xv$ is to compute the cross correlation between $\xv$ and $\yv$ denoted by  $\rv=[r[1],\ldots,r[N]]$
\begin{align}
\label{Eqn:DefCrossCorrelation}
r[m]=(\xv*\yv)[m] \defeq \sum_{i=1}^{M} x[m+i-1] y[i]
\end{align}
and choosing the index $m$ that maximizes $r[m]$. This approach uses all the $N$ samples of $\xv$ and has a super-linear computational complexity of $MN = N^{1+\mu}$. A computationally more efficient approach uses the fact that $\rv$ can be computed by taking the inverse Fourier transform of the product of the Fourier transforms of $\xv$ and $ \yv^*[-n]$, where $\yv^*[-n]$ is the conjugate of time reversed $\yv$. Such an approach still uses all the $N$ samples of $\xv$ but reduces the computational complexity to $O(N \log N)$. Note that even though the Fourier transform of $\xv$ can be precomputed, the $N$-point Fourier transform of $\yv$ still needs to be computed resulting in the $O(N \log N)$ computational complexity.

Both the exact pattern matching problem and the approximate pattern matching problem have been extensively studied in computer science and two recent papers \cite{andoni2013shift} and \cite{amir2004faster} provide a brief summary of the results. For the exact matching problem, Boyer and Moore presented an algorithm in \cite{boyer1977fast} for finding the first occurrence of the match (only $\tau_1$) that has an expected complexity of $O(N/M \log N) = O(N^{1-\mu} \log N)$, whereas the worst case complexity (depending on $\tau_1$'s) can be $O(N \log N)$. For large $M$, the algorithm indeed has an average complexity that is sub-linear in $N$. This algorithm has been generalized to the approximate pattern matching problem in \cite{chang1994approximate} with an average case complexity of $O(NK/M \log N)$ which provides a sub-linear time algorithm only when $K \ll M$. In the work by Andoni, Hassanieh, Indyk and Katabi \cite{andoni2013shift}, the authors gave the first sub-linear time algorithm with a complexity of $O(N/M^{0.359})$ even for $K = O(M)$.

\section{Our Main Results and Relation to Prior Work}
\label{sec:mainresults}
Assuming that a sketch of $\xv$ of size $O(N/M)$ can be computed and stored,
\begin{enumerate}
  \item For the exact pattern matching problem, we present an algorithm which uses a sketching function for $\yv$ with $O(\max(M \log N, N/M \log N))$ samples and a computational complexity of $O(\max(ML \log N, N/M \log N))$. When $M = N^\mu, L = N^\lambda$, this gives a sub-linear time algorithm.

  \item For the approximate pattern matching problem, for $K = O(M)$, our algorithm has a sketching complexity of $\yv$ is $O(\max(M \log N, N/M \log N))$ samples and computational complexity of $O(\max(ML \log N, N/M \log N))$ for all $K = O(M)$.
\end{enumerate}

Our paper is inspired by and builds on two recent works by Hassanieh et al in \cite{hassanieh2012faster} and Pawar and Ramchandran \cite{pawar2014robust}. In \cite{hassanieh2012faster}, Hassanieh et al., considered the correlation function computation problem for a Global Positioning System (GPS) receiver and exploited the fact that the cross-correlation vector $\rv$ is a very sparse signal in the time domain and, hence, the Fourier transform of $\rv$ need not be evaluated at all the $N$ points. In the GPS application, which was the focus of \cite{hassanieh2012faster}, the query $\yv$ corresponds to the received signal from the satellites and, hence, the length of the query was at least $N$. As a result, the computational complexity is still $O(N \log N)$ (still linear in $N$) and the only the constants were improved in relation to the approach of computing the entire Fourier transform. In a later paper by Andoni {\em et al.,} \cite{andoni2013shift}, a sub-linear time algorithm for shift finding in GPS is presented; however, this algorithm is completely combinatorial and eschews algebraic techniques such as FFT-based techniques.

There are important differences between our paper and \cite{hassanieh2012faster,andoni2013shift,boyer1977fast,amir2004faster}. First and foremost, the algorithms used for pattern matching are entirely different. While their algorithms are combinatorial in nature, our algorithm is algebraic and uses signal processing and coding theoretic primitives. Secondly, the system model considered in our paper is different from the model in \cite{hassanieh2012faster,andoni2013shift,boyer1977fast,amir2004faster} in that we allow for preprocessing or creating a sketch of the data $\xv$. Our algorithm exploits this fact and results in a computational complexity $O(N/M)$ which is better than that in \cite{andoni2013shift} for the approximate pattern matching problem.  Finally, we also consider the problem of finding all matches of the pattern $\yv$ instead of looking for only one match. In \cite{pawar2014robust}, Pawar and Ramchandran present an algorithm based on aliasing and the peeling decoder for computing the Fourier transform of a signal with noisy observations for the case when the Fourier transform is known to be sparse. This algorithm has a complexity of $O(N \log N)$ and they do not consider the pattern matching problem. Our algorithm is similar to that of Pawar and Ramchandran's algorithm with one very important distinction. We modify their algorithm to exploit the fact that the peak of the correlation function of interest is always positive. This modification is key in computing the Sparse Inverse Discrete Fourier Transform (SIDFT) with sub-linear time complexity of $O(N^{1-\alpha} \log N)$, $0 < \alpha \leq 1$ . Thus, one of the main contributions of this paper is to show that signal processing and coding theoretic primitives, i.e., Pawar and Ramchandran's algorithm with some modifications can be used to solve the pattern matching algorithm in sub-linear time. 